# 迭代器和可迭代对象
for i, name in enumerate(['a', 'b', 'c']):
    print(i, name)

# 得到字典第一个key
d = {'foo': 1, 'bar': 2}
print(next(iter(d.keys())))
# 得到列表里第一个符合条件的数
numbers = [3, 6, 8, 2, 21, 30, 42]
print(next(i for i in numbers if i % 7 == 0))

# 可迭代对象不一定是迭代器，但迭代器一定是可迭代对象·
my_list = [1, 2, 3]  # 可迭代对象
my_iterator = iter(my_list)  # 迭代器
print(next(my_iterator))
"""
（1）迭代与迭代器原理· 使用iter()函数会尝试获取一个迭代器对象· 使用next()函数会获取迭代器的下一个内容· 
可以将for循环简单地理解为while循环+不断调用next()· 自定义迭代器需要实现__iter__和__next__两个魔法方法· 
生成器对象是迭代器的一种· iter(callable, sentinel)可以基于可调用对象构造一个迭代器
（2）迭代器与可迭代对象· 迭代器和可迭代对象是不同的概念· 可迭代对象不一定是迭代器，但迭代器一定是可迭代对象· 
对可迭代对象使用iter()会返回迭代器，迭代器则会返回它自身· 每个迭代器的被迭代过程是一次性的，可迭代对象则不一定· 
可迭代对象只需要实现__iter__方法，而迭代器要额外实现__next__方法
（3）代码可维护性技巧· 通过定义生成器函数来修饰可迭代对象，可以优化循环内部代码· itertools模块里有许多函数可以用来修饰可迭代对象· 
生成器函数可以用来解耦循环代码，提升可复用性· 不要使用多个break，拆分为函数然后直接return更好· 使用next()函数有时可以完成一些意想不到的功能
（4）文件操作知识· 使用标准做法读取文件内容，在处理没有换行符的大文件时会很慢· 调用file.read()方法可以解决读取大文件的性能问题
"""


